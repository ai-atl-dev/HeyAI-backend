steps:
  # Step 1: Install dependencies and verify checksums
  - name: 'gcr.io/cloud-builders/go'
    id: 'download-dependencies'
    args: ['mod', 'download']
    env:
      - 'GO111MODULE=on'
      - 'GOPROXY=https://proxy.golang.org'

  # Step 2: Verify Go modules
  - name: 'gcr.io/cloud-builders/go'
    id: 'verify-modules'
    args: ['mod', 'verify']
    waitFor: ['download-dependencies']

  # Step 3: Check code formatting
  - name: 'gcr.io/cloud-builders/go'
    id: 'check-formatting'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code is not formatted. Run 'gofmt -s -w .'"
          gofmt -s -l .
          exit 1
        fi
    waitFor: ['download-dependencies']

  # Step 4: Run go vet
  - name: 'gcr.io/cloud-builders/go'
    id: 'vet'
    args: ['vet', './...']
    waitFor: ['download-dependencies']

  # Step 5: Run linting
  - name: 'golangci/golangci-lint:latest'
    id: 'lint'
    args: ['golangci-lint', 'run', '--timeout', '5m']
    waitFor: ['download-dependencies']

  # Step 6: Check for vulnerabilities
  - name: 'golang:1.21'
    id: 'vulnerability-scan'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck ./...
    waitFor: ['download-dependencies']

  # Step 7: Run unit tests with coverage
  - name: 'gcr.io/cloud-builders/go'
    id: 'unit-tests'
    args: ['test', './...', '-v', '-coverprofile=coverage.out', '-covermode=atomic']
    env:
      - 'CGO_ENABLED=0'
    waitFor: ['verify-modules', 'vet']

  # Step 8: Check test coverage threshold
  - name: 'gcr.io/cloud-builders/go'
    id: 'coverage-check'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//' > coverage.txt
        COVERAGE=$(cat coverage.txt)
        echo "Total coverage: $COVERAGE%"
        if [ $(echo "$COVERAGE < 70" | bc) -eq 1 ]; then
          echo "Coverage is below 70% threshold"
          exit 1
        fi
    waitFor: ['unit-tests']

  # Step 9: Run tests with race detector
  - name: 'gcr.io/cloud-builders/go'
    id: 'race-detection'
    args: ['test', './...', '-race', '-short']
    env:
      - 'CGO_ENABLED=1'
    waitFor: ['verify-modules']

  # Step 10: Run benchmarks
  - name: 'gcr.io/cloud-builders/go'
    id: 'benchmarks'
    args: ['test', './...', '-bench=.', '-benchmem', '-run=^$']
    waitFor: ['unit-tests']

  # Step 11: Build the application
  - name: 'gcr.io/cloud-builders/go'
    id: 'build-binary'
    args: ['build', '-v', '-o', 'server', './cmd/server']
    env:
      - 'CGO_ENABLED=0'
      - 'GOOS=linux'
      - 'GOARCH=amd64'
    waitFor: ['unit-tests', 'race-detection', 'lint']

  # Step 12: Build Docker image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build-image'
    args:
      - 'build'
      - '-t'
      - 'gcr.io/$PROJECT_ID/dashboard-backend:$COMMIT_SHA'
      - '-t'
      - 'gcr.io/$PROJECT_ID/dashboard-backend:$BRANCH_NAME'
      - '-t'
      - 'gcr.io/$PROJECT_ID/dashboard-backend:latest'
      - '--cache-from'
      - 'gcr.io/$PROJECT_ID/dashboard-backend:latest'
      - '.'
    waitFor: ['build-binary']

  # Step 13: Scan Docker image for vulnerabilities
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'scan-image'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        gcloud artifacts docker images scan gcr.io/$PROJECT_ID/dashboard-backend:$COMMIT_SHA \
          --location=us \
          --format=json || true
    waitFor: ['build-image']

  # Step 14: Push Docker image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-image'
    args: ['push', '--all-tags', 'gcr.io/$PROJECT_ID/dashboard-backend']
    waitFor: ['build-image', 'scan-image']

  # Step 15: Deploy to Cloud Run (staging)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'deploy-staging'
    entrypoint: 'gcloud'
    args:
      - 'run'
      - 'deploy'
      - 'dashboard-backend-staging'
      - '--image'
      - 'gcr.io/$PROJECT_ID/dashboard-backend:$COMMIT_SHA'
      - '--region'
      - 'us-central1'
      - '--platform'
      - 'managed'
      - '--service-account'
      - 'dashboard-backend-sa@$PROJECT_ID.iam.gserviceaccount.com'
      - '--set-env-vars'
      - 'GCP_PROJECT_ID=$PROJECT_ID,GCP_REGION=us-central1,BIGQUERY_DATASET=agent_data,ENVIRONMENT=staging'
      - '--set-secrets'
      - 'TWILIO_AUTH_TOKEN=twilio-auth-token:latest,OAUTH_CLIENT_SECRET=oauth-client-secret:latest'
      - '--allow-unauthenticated'
      - '--max-instances'
      - '10'
      - '--memory'
      - '512Mi'
      - '--cpu'
      - '1'
      - '--timeout'
      - '300'
    waitFor: ['push-image']

  # Step 16: Run smoke tests on staging
  - name: 'gcr.io/cloud-builders/curl'
    id: 'smoke-test-staging'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        sleep 10
        SERVICE_URL=$(gcloud run services describe dashboard-backend-staging --region=us-central1 --format='value(status.url)')
        curl -f $SERVICE_URL/health || exit 1
        echo "Staging smoke tests passed"
    waitFor: ['deploy-staging']

  # Step 17: Deploy to production (only on main branch)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'deploy-production'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        if [ "$BRANCH_NAME" = "main" ]; then
          gcloud run deploy dashboard-backend \
            --image gcr.io/$PROJECT_ID/dashboard-backend:$COMMIT_SHA \
            --region us-central1 \
            --platform managed \
            --service-account dashboard-backend-sa@$PROJECT_ID.iam.gserviceaccount.com \
            --set-env-vars GCP_PROJECT_ID=$PROJECT_ID,GCP_REGION=us-central1,BIGQUERY_DATASET=agent_data,ENVIRONMENT=production \
            --set-secrets TWILIO_AUTH_TOKEN=twilio-auth-token:latest,OAUTH_CLIENT_SECRET=oauth-client-secret:latest \
            --allow-unauthenticated \
            --max-instances 100 \
            --min-instances 1 \
            --memory 1Gi \
            --cpu 2 \
            --timeout 300 \
            --no-traffic
          
          # Gradual rollout: send 10% traffic to new version
          gcloud run services update-traffic dashboard-backend \
            --region us-central1 \
            --to-latest=10
          
          echo "Deployed to production with 10% traffic"
        else
          echo "Skipping production deployment (not main branch)"
        fi
    waitFor: ['smoke-test-staging']

  # Step 18: Run smoke tests on production
  - name: 'gcr.io/cloud-builders/curl'
    id: 'smoke-test-production'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        if [ "$BRANCH_NAME" = "main" ]; then
          sleep 10
          SERVICE_URL=$(gcloud run services describe dashboard-backend --region=us-central1 --format='value(status.url)')
          curl -f $SERVICE_URL/health || exit 1
          echo "Production smoke tests passed"
        else
          echo "Skipping production smoke tests"
        fi
    waitFor: ['deploy-production']

# Artifacts to save
artifacts:
  objects:
    location: 'gs://$PROJECT_ID-build-artifacts'
    paths:
      - 'coverage.out'
      - 'coverage.txt'
      - 'server'

# Build options
options:
  # Use higher CPU machine for faster builds
  machineType: 'E2_HIGHCPU_8'
  
  # Enable Docker layer caching
  substitutionOption: 'ALLOW_LOOSE'
  
  # Logging options
  logging: CLOUD_LOGGING_ONLY
  
  # Build timeout
  timeout: '1800s'
  
  # Dynamic substitutions
  dynamicSubstitutions: true

# Timeout for entire build
timeout: '1800s'

# Substitutions for variables
substitutions:
  _DEPLOY_REGION: 'us-central1'
  _SERVICE_NAME: 'dashboard-backend'

# Available logs
logsBucket: 'gs://$PROJECT_ID-build-logs'
